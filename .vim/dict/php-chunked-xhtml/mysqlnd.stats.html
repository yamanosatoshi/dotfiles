<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>統計情報</title>
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-base.css" />
<link media="all" rel="stylesheet" type="text/css" href="styles/03e73060321a0a848018724a6c83de7f-theme-medium.css" />

 </head>
 <body class="docs"><div class="navbar navbar-fixed-top">
  <div class="navbar-inner clearfix">
    <ul class="nav" style="width: 100%">
      <li style="float: left;"><a href="mysqlnd.persist.html">« 持続的接続</a></li>
      <li style="float: right;"><a href="mysqlnd.notes.html">メモ »</a></li>
    </ul>
  </div>
</div>
<div id="breadcrumbs" class="clearfix">
  <ul class="breadcrumbs-container">
    <li><a href="index.html">PHP Manual</a></li>
    <li><a href="book.mysqlnd.html">Mysqlnd</a></li>
    <li>統計情報</li>
  </ul>
</div>
<div id="layout">
  <div id="layout-content"><div id="mysqlnd.stats" class="chapter">
 <h1>統計情報</h1>

 <p class="para">
  <em class="emphasis">統計情報を使う</em>
 </p>
 <p class="para">
  MySQL Native Driver は、クライアントとサーバー間の通信に関する統計情報を収集する機能をサポートしています。収集できる統計情報は主に2つのタイプに分けられます。
 </p>
 <ul class="itemizedlist">
  <li class="listitem">
   <p class="para">
    クライアントの統計情報
   </p>
  </li>
  <li class="listitem">
   <p class="para">
    接続の統計情報
   </p>
  </li>
 </ul>
 <p class="para">
  <code class="literal">mysqli</code> 拡張機能を使っている場合、これらの統計情報は以下の2つのAPIを呼び出すことで取得できます。
 </p>
 <ul class="itemizedlist">
  <li class="listitem">
   <p class="para">
    <span class="function"><a href="function.mysqli-get-client-stats.html" class="function">mysqli_get_client_stats()</a></span>
   </p>
  </li>
  <li class="listitem">
   <p class="para">
    <span class="function"><a href="mysqli.get-connection-stats.html" class="function">mysqli_get_connection_stats()</a></span>
   </p>
  </li>
 </ul>
 <blockquote class="note"><p><strong class="note">注意</strong>: 
  <p class="para">
   MySQL Native Driver を使っているすべての拡張機能が統計情報を収集します。たとえば、<code class="literal">ext/mysql</code> や <code class="literal">ext/mysqli</code> を MySQL Native Driver を使ってコンパイルし、<code class="literal">ext/mysql</code> や <code class="literal">ext/mysqli</code> の関数を呼び出すと、収集される統計情報の値が変わります。MySQL Native Driver を使ってコンパイルされた MySQL 拡張機能の呼び出しが、どの程度統計情報に影響を与えるかはわかりません。PDO MySQL Driver や <code class="literal">ext/mysql</code> や <code class="literal">ext/mysqli</code> を、オプションで MySQL Native Driver を使うように設定することができます。こうすると、すべての拡張機能で統計情報を変化させることができます。
  </p>
 </p></blockquote>
 <p class="para">
  <em class="emphasis">クライアントの統計情報にアクセスする</em>
 </p>
 <p class="para">
  クライアントの統計情報にアクセスするには、<span class="function"><a href="function.mysqli-get-client-stats.html" class="function">mysqli_get_client_stats()</a></span> 関数を呼び出す必要があります。この関数を呼び出すのに引数は必要ありません。
 </p>
 <p class="para">
  この関数は、統計情報の名前をキーとして対応するデータを値とする連想配列を返します。
 </p>
 <p class="para">
  クライアントの統計情報は <span class="function"><a href="function.phpinfo.html" class="function">phpinfo()</a></span> 関数を呼び出してもアクセスできます。
 </p>
 <p class="para">
  <em class="emphasis">接続の統計情報にアクセスする</em>
 </p>
 <p class="para">
  接続の統計情報にアクセスするには <span class="function"><a href="mysqli.get-connection-stats.html" class="function">mysqli_get_connection_stats()</a></span> 関数を使います。この関数は接続ハンドルを引数にとります。
 </p>
 <p class="para">
  この関数は、統計情報の名前をキーとして対応するデータを値とする連想配列を返します。
 </p>
 <p class="para">
  <em class="emphasis">結果セットをバッファリングさせるか否か</em>
 </p>
 <p class="para">
  結果セットはバッファリングさせることもできますし、しないこともできます。デフォルトの設定では、<code class="literal">ext/mysql</code> と <code class="literal">ext/mysqli</code> は通常の (プリペアドステートメントでない) クエリの場合結果セットをバッファリングします。バッファリングされた結果セットはクライアント側でキャッシュされます。クエリが実行された後、すべての結果がMySQLサーバから取得され、クライアント側でキャッシュに保存されます。結果セットをバッファリングすることの大きな利点は、一度クライアントが結果を取得すると、サーバがすべての結果セットに割り当てられたリソースを開放できることです。
 </p>
 <p class="para">
  一方、結果セットをバッファリングしない場合、結果セットはサーバ側にバッファリングするよりも長く残ります。仮にクライアント側でのメモリ使用量を削減したいが、サーバ側の負荷が高くなっても構わない場合、結果セットをバッファリングしないようにします。仮にサーバの負荷が高く、バッファリングしていない結果セットの量がサーバ側で多いことが分かっている場合、その負荷をクライアント側に移すことを検討すべきです。クライアントは通常の場合サーバよりも分散しやすいからです。ここでいう <q class="quote">負荷</q> とはメモリバッファに対するものだけでなく、サーバが結果セットを開放する前に他のリソース、たとえばファイルハンドルやスレッドを開きっぱなしにする必要があることも指しています。
 </p>
 <p class="para">
  プリペアドステートメントはデフォルトでは結果セットをバッファリングしません。しかし、<span class="function"><a href="mysqli-stmt.store-result.html" class="function">mysqli_stmt_store_result()</a></span> 関数を使えば、結果セットのバッファリングを有効にすることができます。
 </p>
 <p class="para">
  <em class="emphasis">MySQL Native Driver が返す統計情報</em>
 </p>
 <p class="para">
  以下の表で、<span class="function"><a href="function.mysqli-get-client-stats.html" class="function">mysqli_get_client_stats()</a></span>,
  <span class="function"><a href="mysqli.get-connection-stats.html" class="function">mysqli_get_connection_stats()</a></span> 関数が返す統計情報のリストを示します。
 </p>
 <table id="mysqlnd.stats.returns" class="doctable table">
  <caption><strong>MySQL Native Driver が返す統計情報: ネットワーク関連</strong></caption>
  
   <col width="10*" />
   <col width="10*" />
   <col width="40*" />
   <col width="40*" />
   <thead>
    <tr>
     <th>統計情報</th>
     <th>統計のカテゴリ</th>
     <th>説明</th>
     <th>注意点</th>
    </tr>

   </thead>

   <tbody class="tbody">
    <tr>
     <td><code class="literal">bytes_sent</code></td>
     <td>Connection</td>
     <td>PHP から MySQLサーバに送信されたバイト数</td>
     <td>圧縮プロトコルの効率をチェックするのに使えます</td>
    </tr>

    <tr>
     <td><code class="literal">bytes_received</code></td>
     <td>Connection</td>
     <td>MySQLサーバから受け取ったバイト数</td>
     <td>同上</td>
    </tr>

    <tr>
     <td><code class="literal">packets_sent</code></td>
     <td>Connection</td>
     <td>MySQL のクライアントサーバプロトコルにおいて送信されたパケット数</td>
     <td>クライアントサーバプロトコルの実装をデバッグするのに使われます</td>
    </tr>

    <tr>
     <td><code class="literal">packets_received</code></td>
     <td>Connection</td>
     <td>MySQL のクライアントサーバプロトコルにおいて受信したパケット数</td>
     <td>同上</td>
    </tr>

    <tr>
     <td><code class="literal">protocol_overhead_in</code></td>
     <td>Connection</td>
     <td>MySQL のクライアントサーバプロトコルの受信側の通信にかかるオーバーヘッドをバイト単位で示します。現状はパケットヘッダ(4バイト)のみをオーバーヘッドと看做しています。
      protocol_overhead_in = packets_received * 4で表されます。</td>
     <td>同上</td>
    </tr>

    <tr>
     <td><code class="literal">protocol_overhead_out</code></td>
     <td>Connection</td>
     <td>MySQL のクライアントサーバプロトコルの受信側の通信にかかるオーバーヘッドをバイト単位で示します。現状はパケットヘッダ(4バイト)のみをオーバーヘッドと看做しています。
      protocol_overhead_out = packets_sent * 4で表されます。</td>
     <td>同上</td>
    </tr>

    <tr>
     <td><code class="literal">bytes_received_ok_packet</code></td>
     <td>Connection</td>
     <td>MySQL のクライアントサーバプロトコルにおけるOKパケットの受信量の合計をバイト単位で示します。
      OKパケットはステータスメッセージも含むことができます。ステータスメッセージの長さは変化しうるため、OKパケットのサイズは固定ではありません。</td>
     <td>クライアントサーバプロトコルの実装をデバッグするのに使われます。受信する合計バイト数には、パケットヘッダ(4バイト, protocol_overhead_in や protocol_overhead_out を参照) のサイズも含まれていることに注意してください</td>
    </tr>

    <tr>
     <td><code class="literal">packets_received_ok</code></td>
     <td>Connection</td>
     <td>MySQL のクライアントサーバプロトコルにおけるOKパケットを受信した数です。</td>
     <td>同上</td>
    </tr>

    <tr>
     <td><code class="literal">bytes_received_eof_packet</code></td>
     <td>Connection</td>
     <td>MySQL のクライアントサーバプロトコルにおけるEOFパケットを受信量の合計をバイト単位で示します。EOFパケットはサーバのバージョンによってサイズが変わります。また、EOFパケットはエラーメッセージも伝えることができます。</td>
     <td>同上</td>
    </tr>

    <tr>
     <td><code class="literal">packets_received_eof</code></td>
     <td>Connection</td>
     <td>MySQL のクライアントサーバプロトコルにおけるEOFパケットの数を示します。EOFパケットの数は、PHPが期待するパケットを受け取らなかった場合であっても増加します。これは他のパケット数を示す統計情報と同じです。PHPが期待しないパケットの例は、エラーメッセージが挙げられます。</td>
     <td>同上</td>
    </tr>

    <tr>
     <td><code class="literal">bytes_received_rset_header_packet</code></td>
     <td>Connection</td>
     <td>MySQL のクライアントサーバプロトコルにおける結果セットにあるヘッダパケットの合計サイズをバイト単位で示します。パケットのサイズはペイロード(<code class="literal">LOAD LOCAL INFILE</code>, <code class="literal">INSERT</code>, <code class="literal">UPDATE</code>, <code class="literal">SELECT</code>, エラーメッセージ)に応じて変わります。</td>
     <td>同上</td>
    </tr>

    <tr>
     <td><code class="literal">packets_received_rset_header</code></td>
     <td>Connection</td>
     <td>MySQL のクライアントサーバプロトコルにおける結果セットにあるヘッダパケットの数を示します</td>
     <td>同上</td>
    </tr>

    <tr>
     <td><code class="literal">bytes_received_rset_field_meta_packet</code></td>
     <td>Connection</td>
     <td>MySQL のクライアントサーバプロトコルにおける結果セットにあるメタデータ(カラム情報) の合計サイズをバイト単位で示します。もちろん、メタデータのサイズは結果セットにあるカラムによって変わります。このパケットはペイロードが COM_LIST_FIELDS の場合(訳注：テーブルのカラム情報を得るためのMySQLプロトコル http://dev.mysql.com/doc/internals/en/text-protocol.html#com-field-list)の場合は、エラーメッセージかEOFパケットを返す可能性があります。</td>
     <td>同上</td>
    </tr>

    <tr>
     <td><code class="literal">packets_received_rset_field_meta</code></td>
     <td>Connection</td>
     <td>MySQL のクライアントサーバプロトコルにおける結果セットにあるメタデータ(カラム情報) のパケット数を示します。</td>
     <td>同上</td>
    </tr>

    <tr>
     <td><code class="literal">bytes_received_rset_row_packet</code></td>
     <td>Connection</td>
     <td>MySQL のクライアントサーバプロトコルにおける結果セットにある行情報パケットの合計サイズをバイト単位で示します。このパケットはエラー情報またはEOFパケットを送信する場合もあります。
      <code class="literal">bytes_received_rset_row_packet</code> の数から、<code class="literal">rows_fetched_from_server_normal</code> と <code class="literal">rows_fetched_from_server_ps</code> の値を引くことによって、エラー数やEOFパケットの数を割り出すことができます。</td>
     <td>同上</td>
    </tr>

    <tr>
     <td><code class="literal">packets_received_rset_row</code></td>
     <td>Connection</td>
     <td>MySQL のクライアントサーバプロトコルの結果セット行データパケットと、それらの合計サイズをバイト単位で示します。</td>
     <td>同上</td>
    </tr>

    <tr>
     <td><code class="literal">bytes_received_prepare_response_packet</code></td>
     <td>Connection</td>
     <td>MySQL のクライアントサーバプロトコルにおける、プリペアドステートメント初期化パケット(prepared statement init packets) が OK を返した合計サイズをバイト単位で示します。このパケットはエラーを送信する可能性もあります。このパケットのサイズは MySQL のバージョンによって変わります。: MySQL 4.1 では 9バイト、 MySQ 5.0 以降は 12 byte です。エラーが起きた回数を安全に知る方法はありません。たとえば、MySQL 5.0 以降の MySQL に常に接続している場合は、<code class="literal">bytes_received_prepare_response_packet</code> != <code class="literal">packets_received_prepare_response</code> * 12 の場合にエラーが起きていると推定できるかもしれません。<code class="literal">ps_prepared_never_executed</code> や <code class="literal">ps_prepared_once_executed</code> も参照してください。</td>
     <td>同上</td>
    </tr>

    <tr>
     <td><code class="literal">packets_received_prepare_response</code></td>
     <td>Connection</td>
     <td>MySQL のクライアントサーバプロトコルにおける、プリペアドステートメント初期化パケット(prepared statement init packets) が OK を返した数</td>
     <td>同上</td>
    </tr>

    <tr>
     <td><code class="literal">bytes_received_change_user_packet</code></td>
     <td>Connection</td>
     <td>MySQL のクライアントサーバプロトコルにおける、COM_CHANGE_USER パケットの合計サイズをバイト単位で示します。このパケットはエラーやEOFパケットを送信する可能性もあります。</td>
     <td>同上</td>
    </tr>

    <tr>
     <td><code class="literal">packets_received_change_user</code></td>
     <td>Connection</td>
     <td>MySQL のクライアントサーバプロトコルにおける、COM_CHANGE_USER パケットの数</td>
     <td>同上</td>
    </tr>

    <tr>
     <td><code class="literal">packets_sent_command</code></td>
     <td>Connection</td>
     <td>PHP から MySQL に送信されたMySQL クライアントサーバプロトコルコマンドの合計数。特定のどのコマンドが送信されたか、そしてそれらのうちどのくらいが実際に送信されたかを知る方法はありません。この統計値は、PHPバイナリで MySQLのサポートを無効にすることを確かめる手がかりを知るために、PHP がコマンドを送信しているかどうかを知る手段として使えるくらいです。また、データを MySQL に送信している間にエラーが起きた回数を知る方法もありません。記録されるエラーは command_buffer_too_small (後述) の値くらいです。</td>
     <td>MySQL のクライアントサーバプロトコルのデバッグする用途だけに役立ちます。</td>
    </tr>

    <tr>
     <td><code class="literal">bytes_received_real_data_normal</code></td>
     <td>Connection</td>
     <td>PHP クライアントが <code class="literal">mysqlnd</code> からテキストプロトコル経由で受け取ったペイロードの合計バイト数。</td>
     <td>これは、プリペアドステートメントではないクエリから生成され、PHPクライアントが取得した結果セットに含まれる実際のデータサイズです。完全な結果セットは <code class="literal">mysqlnd</code> が MySQL から取得しますが、この統計値は PHP クライアントが <code class="literal">mysqlnd</code> から実際に取得した実際のデータのみを数えていることに注意してください。この統計値を増やすコードの例は以下のようになります:
<div class="example-contents">
<div class="cdata"><pre>
$mysqli = new mysqli();
$res = $mysqli-&gt;query(&quot;SELECT &#039;abc&#039;&quot;);
$res-&gt;fetch_assoc();
$res-&gt;close();
</pre></div>
</div>

      <p class="para">
       毎回取得(fetch)操作をするたびにこの値が増加します。
      </p>

      <p class="para">
       この統計値は、結果セットがクライアント上でバッファリングされただけで、実際に取得されていない場合は変化しません。たとえば、次のようなコードの場合です:
      </p>
<div class="example-contents">
<div class="cdata"><pre>
$mysqli = new mysqli();
$res = $mysqli-&gt;query(&quot;SELECT &#039;abc&#039;&quot;);
$res-&gt;close();
</pre></div>
</div>

      </td>
    </tr>

    <tr>
     <td><code class="literal">bytes_received_real_data_ps</code></td>
     <td>Connection</td>
     <td>PHP クライアントが <code class="literal">mysqlnd</code> からプリペアドステートメントプロトコル経由で受け取ったペイロードの合計バイト数。</td>
     <td>これは、プリペアドステートメントプロトコルを使ってから生成され、PHPクライアントが取得した結果セットに含まれる実際のデータサイズです。この値は、PHPクライアントが読み取らなければ変化しません。完全な結果セットは <code class="literal">mysqlnd</code> が MySQL から取得しますが、この統計値は PHP クライアントが <code class="literal">mysqlnd</code> から実際に取得した実際のデータのみを数えていることに注意してください。<code class="literal">bytes_received_real_data_normal</code> も参照してください。</td>
    </tr>

   </tbody>
  
 </table>

 <p class="para">
  <em class="emphasis">Result Set</em>
 </p>
 <table id="mysqlnd.stats.results" class="doctable table">
  <caption><strong>MySQL Native Driver が返す統計情報: 結果セット</strong></caption>
  
   <col width="10*" />
   <col width="10*" />
   <col width="40*" />
   <col width="40*" />
   <thead>
    <tr>
     <th>統計情報</th>
     <th>統計のカテゴリ</th>
     <th>説明</th>
     <th>注意点</th>
    </tr>

   </thead>

   <tbody class="tbody">
    <tr>
     <td><code class="literal">result_set_queries</code></td>
     <td>Connection</td>
     <td>結果セットを生成したクエリの数。結果セットを生成するクエリの例: <code class="literal">SELECT</code>,
      <code class="literal">SHOW</code>. 結果セットのヘッダパケットを読み取っている間にエラーが発生した場合、この統計値はインクリメントされません</td>
     <td>たとえば、データベースに高い負荷をかけているクライアントを特定する目的で、PHP が MySQL に送信したクエリの数を間接的に測るのに使えます。</td>
    </tr>

    <tr>
     <td><code class="literal">non_result_set_queries</code></td>
     <td>Connection</td>
     <td>結果セットを生成しなかったクエリの数。結果セットを生成しないクエリの例:<code class="literal">INSERT</code>, <code class="literal">UPDATE</code>, <code class="literal">LOAD DATA</code>。結果セットのヘッダパケットを読み取っている間にエラーが発生した場合、この統計値はインクリメントされません。</td>
     <td>同上</td>
    </tr>

    <tr>
     <td><code class="literal">no_index_used</code></td>
     <td>Connection</td>
     <td>結果セットを生成したが、インデックスを使わなかったクエリの数 (mysqld の起動オプション -log-queries-not-using-indexes も参照してください) こうしたクエリを記録したい場合、mysqli_report(MYSQLI_REPORT_INDEX) を使って ext/mysqli に例外をスローさせることができます。例外ではなく警告にとどめたい場合は、mysqli_report(MYSQLI_REPORT_INDEX ^ MYSQLI_REPORT_STRICT) を使ってください。</td>
     <td class="empty">&nbsp;</td>
    </tr>

    <tr>
     <td><code class="literal">bad_index_used</code></td>
     <td>Connection</td>
     <td>結果セットを生成したが、良いインデックスを使わなかったクエリの数 (mysqld の起動オプション -log-slow-queries も参照してください)</td>
     <td>こうしたクエリを記録したい場合、mysqli_report(MYSQLI_REPORT_INDEX) を使って ext/mysqli に例外をスローさせることができます。例外ではなく警告にとどめたい場合は、mysqli_report(MYSQLI_REPORT_INDEX ^ MYSQLI_REPORT_STRICT) を使ってください。</td>
    </tr>

    <tr>
     <td><code class="literal">slow_queries</code></td>
     <td>Connection</td>
     <td>実行に <code class="literal">long_query_time</code> 秒以上かかり、少なくとも <code class="literal">min_examined_row_limit</code> 行以上調べる必要があるSQL</td>
     <td><span class="function"><a href="function.mysqli-report.html" class="function">mysqli_report()</a></span>関数では記録できません</td>
    </tr>

    <tr>
     <td><code class="literal">buffered_sets</code></td>
     <td>Connection</td>
     <td><q class="quote">通常の</q> クエリで返された結果セットのうち、バッファリングされたものの数。<q class="quote">通常の</q> というのは、右の「注意点」で述べている <q class="quote">プリペアドステートメントのことではありません</q></td>
     <td>結果セットをクライアント側にバッファリングするAPI呼び出しの例:
      <span class="function"><a href="function.mysql-query.html" class="function">mysql_query()</a></span>,
      <span class="function"><a href="mysqli.query.html" class="function">mysqli_query()</a></span>,
      <span class="function"><a href="mysqli.store-result.html" class="function">mysqli_store_result()</a></span>,
      <span class="function"><a href="mysqli-stmt.get-result.html" class="function">mysqli_stmt_get_result()</a></span>
      結果セットをクライアント側にバッファリングすると、サーバ側のリソースが迅速に解放され、結果セットを走査しやすくなります。欠点としては、クライアント側のメモリ消費が、バッファリングする分だけ増えてしまうということです。mysqlnd は、PHP の内部的なメモリ管理関数を使っているため、(MySQL Client Library とは異なり) PHP 側の memory_limit の設定を尊重することに注意してください。同じ理由で <span class="function"><a href="function.memory-get-usage.html" class="function">memory_get_usage()</a></span> 関数の実行結果は、MySQL Client Library と比べて高いメモリ使用量を報告します。<span class="function"><a href="function.memory-get-usage.html" class="function">memory_get_usage()</a></span> 関数は MySQL Client Library のメモリ使用量を全く計測しません。なぜなら、MySQL Client Library は この関数が監視する PHP の内部メモリ管理関数を使用していないからです！</td>
    </tr>

    <tr>
     <td><code class="literal">unbuffered_sets</code></td>
     <td>Connection</td>
     <td>通常の(プリペアドステートメントではない) クエリによって返された、バッファリングされていない結果セットの数</td>
     <td>クライアント側で結果セットがバッファリングされないAPI呼び出しの例:
      <span class="function"><a href="mysqli.use-result.html" class="function">mysqli_use_result()</a></span></td>
    </tr>

    <tr>
     <td><code class="literal">ps_buffered_sets</code></td>
     <td>Connection</td>
     <td>プリペアドステートメントによって返される、バッファリングされた結果セットの数。デフォルトでは、プリペアドステートメントはバッファリングされません。</td>
     <td>クライアント側で結果セットがバッファリングされるAPI呼び出しの例:
      <code class="literal">mysqli_stmt_store_result</code></td>
    </tr>

    <tr>
     <td><code class="literal">ps_unbuffered_sets</code></td>
     <td>Connection</td>
     <td>プリペアドステートメントによって返される、バッファリングされない結果セットの数。</td>
     <td>デフォルトでは、プリペアドステートメントはバッファリングされません。</td>
    </tr>

    <tr>
     <td><code class="literal">flushed_normal_sets</code></td>
     <td>Connection</td>
     <td>
      通常の(プリペアドステートメントではない) クエリから返された、クライアントが読み取っていないため黙ってフラッシュされたデータが残っている結果セットの数。フラッシュはバッファリングされていない結果セットの場合だけ起こります。</td>
     <td>
      バッファリングされていない結果セットは、新しいクエリが実行される前に完全に取得されなければなりません。そうでない場合、MySQL はエラーを生成します。アプリケーションがバッファリングされていない結果セットからすべての行を取得していない場合、mysqlnd は行をクリアするため暗黙のうちに結果セットをフラッシュします。<code class="literal">rows_skipped_normal</code> や、<code class="literal">rows_skipped_ps</code> も参照してください。暗黙のフラッシュが起こりうる原因を以下に示します:
      <ul class="itemizedlist">
       <li class="listitem">
        <p class="para">
         クライアントアプリケーションが不完全な場合
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         クライアントは探していた情報を見つけたあと終了しますが、MySQL に必要以上のレコードを計算させてしまっている場合
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         クライアントアプリケーションが予期せず終了する場合
        </p>
       </li>
      </ul></td>
    </tr>

    <tr>
     <td><code class="literal">flushed_ps_sets</code></td>
     <td>Connection</td>
     <td>プリペアドステートメントのクエリから返された、クライアントが読み取っていないため黙ってフラッシュされたデータが残っている結果セットの数。フラッシュはバッファリングされていない結果セットの場合だけ起こります。</td>
     <td>同上</td>
    </tr>

    <tr>
     <td><code class="literal">ps_prepared_never_executed</code></td>
     <td>Connection</td>
     <td>準備(prepare)されたが、決して実行されないステートメントの数</td>
     <td>プリペアドステートメントはサーバのリソースを占有します。実行する予定がない場合、ステートメントを準備すべきではありません。</td>
    </tr>

    <tr>
     <td><code class="literal">ps_prepared_once_executed</code></td>
     <td>Connection</td>
     <td>一度だけ実行されたプリペアドステートメントの数</td>
     <td>
      プリペアドステートメントの背後にあるアイディアのうちのひとつは、同じクエリは繰り返し繰り返し(異なるパラメーターで)実行されるんだから、ステートメントの実行が準備と実行に分かれていれば、クエリのパースやほかの準備処理はキャッシュできる、というものです。 このアイディアは準備を一度行い、その結果を <q class="quote">キャッシュ</q> します。たとえば解析ツリーを複数のステートメントの実行時に再利用するのです。プリペアドステートメントが一度だけしか実行されない場合、二段階に処理が分かれていることは <q class="quote">通常の</q>クエリに比べて非効率かもしれません。なぜなら、すべてのキャッシュは余計なものであり、その情報を保持するためにサーバは(限られた)リソースを消費しているからです。結果的に、一度しか実行されていないプリペアドステートメントはパフォーマンスを害する原因になる可能性があります。
     </td>
    </tr>

    <tr>
     <td><code class="literal">rows_fetched_from_server_normal</code>,
      <code class="literal">rows_fetched_from_server_ps</code></td>
     <td>Connection</td>
     <td>
      クライアントが消費していたかいないかに関わらず、MySQLから取得に成功した結果セット行の合計数。行によっては、クライアントアプリケーションは取得しないため暗黙のうちにフラッシュされている場合があります。</td>
     <td><code class="literal">packets_received_rset_row</code> も参照してください</td>
    </tr>

    <tr>
     <td><code class="literal">rows_buffered_from_client_normal</code>,
      <code class="literal">rows_buffered_from_client_ps</code></td>
     <td>Connection</td>
     <td>
      通常のクエリ、またはプリペアドステートメントから生成された、バッファリングに成功した行の合計数。これは MySQL から取得され、クライアントにバッファリングされた行の数です。バッファリングに成功した行については、ふたつの全く別な統計値があることに注意してください。(MySQL から mysqlnd の内部バッファに)バッファリングされた行の数と、(mysqlnd の内部バッファからクライアントアプリケーションへ)取得され、バッファリングされた行の数です。バッファリングされた行数が、取得されてバッファリングされた行より多い場合、クライアントアプリケーションが必要以上に大きな結果セットを生成しているため、クライアントが読み取らない行ができてしまっている可能性があります。</td>
     <td>結果をバッファリングするクエリの例:
      <span class="function"><a href="mysqli.query.html" class="function">mysqli_query()</a></span>,
      <span class="function"><a href="mysqli.store-result.html" class="function">mysqli_store_result()</a></span></td>
    </tr>

    <tr>
     <td><code class="literal">rows_fetched_from_client_normal_buffered</code>,
      <code class="literal">rows_fetched_from_client_ps_buffered</code></td>
     <td>Connection</td>
     <td>バッファリングされた結果セットからクライアントによって取得された行の合計数。この結果セットは通常のクエリとプリペアドステートメントの両方から生成されたものです。</td>
     <td class="empty">&nbsp;</td>
    </tr>

    <tr>
     <td><code class="literal">rows_fetched_from_client_normal_unbuffered</code>,
      <code class="literal">rows_fetched_from_client_ps_unbuffered</code></td>
     <td>Connection</td>
     <td>バッファリングされて「いない」結果セットからクライアントによって取得された行の合計数。この結果セットは通常のクエリとプリペアドステートメントの両方から生成されたものです。</td>
     <td class="empty">&nbsp;</td>
    </tr>

    <tr>
     <td><code class="literal">rows_fetched_from_client_ps_cursor</code></td>
     <td>Connection</td>
     <td>プリペアドステートメントによって生成されたカーソルから、クライアントが取得した行の合計数</td>
     <td class="empty">&nbsp;</td>
    </tr>

    <tr>
     <td><code class="literal">rows_skipped_normal</code>,
      <code class="literal">rows_skipped_ps</code></td>
     <td>Connection</td>
     <td>将来のために予約されています(今のところサポートされていません)</td>
     <td class="empty">&nbsp;</td>
    </tr>

    <tr>
     <td><code class="literal">copy_on_write_saved</code>,
      <code class="literal">copy_on_write_performed</code></td>
     <td>Process</td>
     <td>
      mysqlnd では、エクステンションから返された値は mysqlnd 内部にある通信結果のバッファを指しています。開発者が値を変更しなければ、取得されたデータは一度だけメモリに保持されます。値を変更した場合、mysqlnd は 内部にある通信結果のバッファを変更から保護するために コピーオンライト を実行しなければなりません。MySQL Client Library を使うと、取得したデータを二度メモリに保持します。MySQL Client Library の内部バッファと変数の値がエクステンションによって返されるのです。理論上、mysqlnd は40%のメモリを節約できます。しかし、メモリに保持されている量は <span class="function"><a href="function.memory-get-usage.html" class="function">memory_get_usage()</a></span>関数では計測できないことに注意してください。</td>
     <td class="empty">&nbsp;</td>
    </tr>

    <tr>
     <td><code class="literal">explicit_free_result</code>,
      <code class="literal">implicit_free_result</code></td>
     <td>Connection, Process (プリペアドステートメントのクリーンアップ時のみ)</td>
     <td>解放された結果セットの合計数</td>
     <td>ここでいう「解放」とは明示的なもので、初期化コマンドで生成された結果セットを除きます。たとえば <code class="literal">mysqli_options(MYSQLI_INIT_COMMAND , ...)</code> 関数の呼び出しがそれにあたります。</td>
    </tr>

    <tr>
     <td><code class="literal">proto_text_fetched_null</code>,
      <code class="literal">proto_text_fetched_bit</code>,
      <code class="literal">proto_text_fetched_tinyint</code>
      <code class="literal">proto_text_fetched_short</code>,
      <code class="literal">proto_text_fetched_int24</code>,
      <code class="literal">proto_text_fetched_int</code>
      <code class="literal">proto_text_fetched_bigint</code>,
      <code class="literal">proto_text_fetched_decimal</code>,
      <code class="literal">proto_text_fetched_float</code>
      <code class="literal">proto_text_fetched_double</code>,
      <code class="literal">proto_text_fetched_date</code>,
      <code class="literal">proto_text_fetched_year</code>
      <code class="literal">proto_text_fetched_time</code>,
      <code class="literal">proto_text_fetched_datetime</code>,
      <code class="literal">proto_text_fetched_timestamp</code>
      <code class="literal">proto_text_fetched_string</code>,
      <code class="literal">proto_text_fetched_blob</code>,
      <code class="literal">proto_text_fetched_enum</code>
      <code class="literal">proto_text_fetched_set</code>,
      <code class="literal">proto_text_fetched_geometry</code>,
      <code class="literal">proto_text_fetched_other</code></td>
     <td>Connection</td>
     <td>通常のクエリ(MySQL テキストプロトコル) から取得したあるタイプのカラムの合計数</td>
     <td>C API/ MySQL のメタデータと 統計の名前の対応:
      <ul class="itemizedlist">
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_NULL</code> - proto_text_fetched_null
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_BIT</code> - proto_text_fetched_bit
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_TINY</code> - proto_text_fetched_tinyint
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_SHORT</code> - proto_text_fetched_short
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_INT24</code> - proto_text_fetched_int24
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_LONG</code> - proto_text_fetched_int
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_LONGLONG</code> -
         proto_text_fetched_bigint
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_DECIMAL</code>,
         <code class="literal">MYSQL_TYPE_NEWDECIMAL</code> -
         proto_text_fetched_decimal
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_FLOAT</code> - proto_text_fetched_float
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_DOUBLE</code> -
         proto_text_fetched_double
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_DATE</code>,
         <code class="literal">MYSQL_TYPE_NEWDATE</code> - proto_text_fetched_date
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_YEAR</code> - proto_text_fetched_year
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_TIME</code> - proto_text_fetched_time
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_DATETIME</code> -
         proto_text_fetched_datetime
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_TIMESTAMP</code> -
         proto_text_fetched_timestamp
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_STRING</code>,
         <code class="literal">MYSQL_TYPE_VARSTRING</code>,
         <code class="literal">MYSQL_TYPE_VARCHAR</code> -
         proto_text_fetched_string
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_TINY_BLOB</code>,
         <code class="literal">MYSQL_TYPE_MEDIUM_BLOB</code>,
         <code class="literal">MYSQL_TYPE_LONG_BLOB</code>,
         <code class="literal">MYSQL_TYPE_BLOB</code> - proto_text_fetched_blob
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_ENUM</code> - proto_text_fetched_enum
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_SET</code> - proto_text_fetched_set
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">MYSQL_TYPE_GEOMETRY</code> -
         proto_text_fetched_geometry
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         上記にない <code class="literal">MYSQL_TYPE_*</code> (ないはずですが) - proto_text_fetched_other
        </p>
       </li>
      </ul>
      <p class="para">
       MYSQL_*-type 定数は、 MySQL の各バージョンの同じSQLカラムタイプと結びついているとは限らないことに注意してください。
      </p></td>
    </tr>

    <tr>
     <td><code class="literal">proto_binary_fetched_null</code>,
      <code class="literal">proto_binary_fetched_bit</code>,
      <code class="literal">proto_binary_fetched_tinyint</code>
      <code class="literal">proto_binary_fetched_short</code>,
      <code class="literal">proto_binary_fetched_int24</code>,
      <code class="literal">proto_binary_fetched_int</code>,
      <code class="literal">proto_binary_fetched_bigint</code>,
      <code class="literal">proto_binary_fetched_decimal</code>,
      <code class="literal">proto_binary_fetched_float</code>,
      <code class="literal">proto_binary_fetched_double</code>,
      <code class="literal">proto_binary_fetched_date</code>,
      <code class="literal">proto_binary_fetched_year</code>,
      <code class="literal">proto_binary_fetched_time</code>,
      <code class="literal">proto_binary_fetched_datetime</code>,
      <code class="literal">proto_binary_fetched_timestamp</code>,
      <code class="literal">proto_binary_fetched_string</code>,
      <code class="literal">proto_binary_fetched_blob</code>,
      <code class="literal">proto_binary_fetched_enum</code>,
      <code class="literal">proto_binary_fetched_set</code>,
      <code class="literal">proto_binary_fetched_geometry</code>,
      <code class="literal">proto_binary_fetched_other</code></td>
     <td>Connection</td>
     <td>プリペアドステートメント(MySQL バイナリプロトコル) から取得したあるタイプのカラムの合計数</td>
     <td>カラムタイプと統計の名前の対応は、上の <code class="literal">proto_text_*</code> を参照してください</td>
    </tr>

   </tbody>
  
 </table>

 <table id="mysqlnd.stats.connection" class="doctable table">
  <caption><strong>MySQL Native Driver が返す統計情報: データベース接続</strong></caption>
  
   <col width="10*" />
   <col width="10*" />
   <col width="40*" />
   <col width="40*" />
   <thead>
    <tr>
     <th>統計情報</th>
     <th>統計のカテゴリ</th>
     <th>説明</th>
     <th>注意点</th>
    </tr>

   </thead>

   <tbody class="tbody">
    <tr>
     <td><code class="literal">connect_success</code>, <code class="literal">connect_failure</code></td>
     <td>Connection</td>
     <td>接続を試みた結果が 成功 / 失敗 した回数の合計</td>
     <td>再利用された接続や、他の種類の接続もすべて含みます</td>
    </tr>

    <tr>
     <td><code class="literal">reconnect</code></td>
     <td>Process</td>
     <td>既に開かれている接続ハンドルに対して(mysqli_real_connectを使って)行われた再接続の合計回数</td>
     <td>次のコードは、再接続を行います。<code class="literal">$link = new mysqli(...);$link-&gt;real_connect(...)</code> しかし、次のコードは再接続を行いません。<code class="literal">$link = new mysqli(...); $link-&gt;connect(...)</code> なぜなら、このコードは新しい接続が確立される前に明示的に既存の接続を閉じるからです。</td>
    </tr>

    <tr>
     <td><code class="literal">pconnect_success</code></td>
     <td>Connection</td>
     <td>持続的接続を試みて成功した合計回数</td>
     <td><code class="literal">connect_success</code> は、持続的接続と通常の接続の両方の成功数を合計している点に注意してください。通常の接続の成功数は、<code class="literal">connect_success</code> - <code class="literal">pconnect_success</code> で求められます。</td>
    </tr>

    <tr>
     <td><code class="literal">active_connections</code></td>
     <td>Connection</td>
     <td>アクティブな持続的接続と通常の接続の合計値</td>
     <td class="empty">&nbsp;</td>
    </tr>

    <tr>
     <td><code class="literal">active_persistent_connections</code></td>
     <td>Connection</td>
     <td>アクティブな持続的接続の合計値</td>
     <td>アクティブな通常の接続の合計値は、<code class="literal">active_connections</code> - <code class="literal">active_persistent_connections</code> で求められます。</td>
    </tr>

    <tr>
     <td><code class="literal">explicit_close</code></td>
     <td>Connection</td>
     <td>明示的に閉じられた接続の合計数(ext/mysqli 限定).</td>
     <td>明示的に接続を閉じるコードの例 :
<div class="example-contents">
<div class="cdata"><pre>
$link = new mysqli(...); $link-&gt;close(...)
$link = new mysqli(...); $link-&gt;connect(...)
</pre></div>
</div>
</td>
    </tr>

    <tr>
     <td><code class="literal">implicit_close</code></td>
     <td>Connection</td>
     <td>暗黙的に閉じられた接続の合計数(ext/mysqli 限定).</td>
     <td>暗黙的に接続を閉じるコードの例 :
      <ul class="itemizedlist">
       <li class="listitem">
        <p class="para">
         <code class="literal">$link = new mysqli(...);
         $link-&gt;real_connect(...)</code>
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">unset($link)</code>
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         持続的接続の場合: プールされる接続は real_connect 関数を使って作成されますが、作成されたハンドルにはどんなオプションが設定されたかわからない場合があります。この場合、暗黙のうちに接続を閉じることで、どんなオプションが設定されたかわからない接続が返されることを防いでください。
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         持続的接続の場合: mysqli::ping や mysqli::change_user を実行すると失敗し、ext/mysqli が接続を閉じてしまいます。
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         スクリプトの実行が終了する時: ユーザーが閉じていない接続は閉じられます。
        </p>
       </li>
      </ul></td>
    </tr>

    <tr>
     <td><code class="literal">disconnect_close</code></td>
     <td>Connection</td>
     <td>接続を試み、C API の<span class="function"><strong>mysql_real_connect()</strong></span> を呼び出した後に失敗した回数</td>
     <td>C API の呼び出しの際に渡された接続ハンドルを閉じるため、<code class="literal">disconnect_close</code> と呼ばれています。</td>
    </tr>

    <tr>
     <td><code class="literal">in_middle_of_command_close</code></td>
     <td>Process</td>
     <td>コマンドの実行中(クエリを送信し、応答を受け取る前に残っていた結果セットが取得されなかったり、データを取得中だったり、LOAD DATA コマンドのデータを送信中だったりした場合)に閉じられた接続</td>
     <td>非同期クエリを使っていない場合、コマンド実行中に接続が閉じられるのは、PHPスクリプトが予期しない箇所で終了し、PHPが接続を閉じた場合だけのはずです。</td>
    </tr>

    <tr>
     <td><code class="literal">init_command_executed_count</code></td>
     <td>Connection</td>
     <td>初期化コマンドが実行された合計回数。たとえば、以下のようなコードが実行された回数です。
      <code class="literal">mysqli_options(MYSQLI_INIT_COMMAND , ...)</code></td>
     <td>初期化コマンドが成功した回数は <code class="literal">init_command_executed_count</code> - <code class="literal">init_command_failed_count</code> で求められます。</td>
    </tr>

    <tr>
     <td><code class="literal">init_command_failed_count</code></td>
     <td>Connection</td>
     <td>初期化コマンドが失敗した回数</td>
     <td class="empty">&nbsp;</td>
    </tr>

   </tbody>
  
 </table>

 <table id="mysqlnd.stats.com" class="doctable table">
  <caption><strong>MySQL Native Driverが返す統計情報: COM_* コマンド</strong></caption>
  
   <col width="10*" />
   <col width="10*" />
   <col width="40*" />
   <col width="40*" />
   <thead>
    <tr>
     <th>統計情報</th>
     <th>統計のカテゴリ</th>
     <th>説明</th>
     <th>注意点</th>
    </tr>

   </thead>

   <tbody class="tbody">
    <tr>
     <td><code class="literal">com_quit</code>, <code class="literal">com_init_db</code>,
      <code class="literal">com_query</code>, <code class="literal">com_field_list</code>,
      <code class="literal">com_create_db</code>, <code class="literal">com_drop_db</code>,
      <code class="literal">com_refresh</code>, <code class="literal">com_shutdown</code>,
      <code class="literal">com_statistics</code>,
      <code class="literal">com_process_info</code>,
      <code class="literal">com_connect</code>,
      <code class="literal">com_process_kill</code>, <code class="literal">com_debug</code>,
      <code class="literal">com_ping</code>, <code class="literal">com_time</code>,
      <code class="literal">com_delayed_insert</code>,
      <code class="literal">com_change_user</code>,
      <code class="literal">com_binlog_dump</code>,
      <code class="literal">com_table_dump</code>,
      <code class="literal">com_connect_out</code>,
      <code class="literal">com_register_slave</code>,
      <code class="literal">com_stmt_prepare</code>,
      <code class="literal">com_stmt_execute</code>,
      <code class="literal">com_stmt_send_long_data</code>,
      <code class="literal">com_stmt_close</code>,
      <code class="literal">com_stmt_reset</code>,
      <code class="literal">com_stmt_set_option</code>,
      <code class="literal">com_stmt_fetch</code>, <code class="literal">com_daemon</code></td>
     <td>Connection</td>
     <td>PHP から MySQL へ、特定の COM_* コマンドを送信しようとした合計回数</td>
     <td><p class="para">
       これらの統計値は、コマンドをチェックした後、対応する MySQLクライアントサーバプロトコルのパケットが送信される前にインクリメントされます。mysqlnd がパケットの送信に失敗したとしても、統計情報は減りません。パケットの送信にした場合、PHP は <q class="quote">Error while sending %s packet. PID=%d.</q> という、E_WARNING レベルの警告を発生させます。
      </p>

      <p class="para">
       使い方の例:
      </p>
      <ul class="itemizedlist">
       <li class="listitem">
        <p class="para">
         PHP があるコマンドを MySQLに送信しているかどうかをチェックする。たとえば、クライアントが <code class="literal">COM_PROCESS_KILL</code> を送信しているかどうかをチェックする。
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">COM_EXECUTE</code> コマンドと <code class="literal">COM_PREPARE</code> コマンドの実行回数を比較することで、プリペアドステートメントの平均実行回数を割り出す。
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">COM_QUERY</code> コマンドの実行回数がゼロかどうかをチェックすることで、PHP がプリペアドステートメントでない通常のクエリを実行しているかどうかをチェックする
        </p>
       </li>
       <li class="listitem">
        <p class="para">
         <code class="literal">COM_QUERY</code> と <code class="literal">COM_EXECUTE</code> コマンドをチェックすることで、SQLを実行しすぎているPHPスクリプトを特定する
        </p>
       </li>
      </ul></td>
    </tr>

   </tbody>
  
 </table>

 <p class="para">
  <em class="emphasis">その他</em>
 </p>
 <table id="mysqlnd.stats.misc" class="doctable table">
  <caption><strong>MySQL Native Driver が返す統計情報: その他</strong></caption>
  
   <col width="10*" />
   <col width="10*" />
   <col width="40*" />
   <col width="40*" />
   <thead>
    <tr>
     <th>統計情報</th>
     <th>統計のカテゴリ</th>
     <th>説明</th>
     <th>注意点</th>
    </tr>

   </thead>

   <tbody class="tbody">
    <tr>
     <td><code class="literal">explicit_stmt_close</code>,
      <code class="literal">implicit_stmt_close</code></td>
     <td>プロセス</td>
     <td>プリペアドステートメントが閉じられた合計回数</td>
     <td>プリペアドステートメントは、常に明示的に閉じられるものとみなされます。ただし、prepare に失敗した場合を除きます。</td>
    </tr>

    <tr>
     <td><code class="literal">mem_emalloc_count</code>,
      <code class="literal">mem_emalloc_ammount</code>,
      <code class="literal">mem_ecalloc_count</code>,
      <code class="literal">mem_ecalloc_ammount</code>,
      <code class="literal">mem_erealloc_count</code>,
      <code class="literal">mem_erealloc_ammount</code>,
      <code class="literal">mem_efree_count</code>,
      <code class="literal">mem_malloc_count</code>,
      <code class="literal">mem_malloc_ammount</code>,
      <code class="literal">mem_calloc_count</code>,
      <code class="literal">mem_calloc_ammount</code>,
      <code class="literal">mem_realloc_count</code>,
      <code class="literal">mem_realloc_ammount</code>,
      <code class="literal">mem_free_count</code></td>
     <td>Process</td>
     <td>メモリ管理に関する関数コールの回数</td>
     <td>開発者だけが使うものです。</td>
    </tr>

    <tr>
     <td><code class="literal">command_buffer_too_small</code></td>
     <td>データベース接続</td>
     <td>PHP が MySQL にコマンドを送信する際、コマンドバッファの大きさが拡張された回数</td>
     <td>
      <p class="para">
       mysqlnd は、内部的に <code class="literal">mysqlnd.net_cmd_buffer_size</code>(<var class="filename">php.ini</var>で設定) バイトを接続毎にメモリに割り当てます。MySQL のクライアントサーバプロトコルの場合、<code class="literal">COM_QUERY</code> (通常クエリ) コマンドがバッファサイズより大きい場合、mysqlnd はコマンドを送信するのに必要なサイズまでバッファを拡張します。ひとつの接続につきバッファが拡張された際はいつでも、<code class="literal">command_buffer_too_small</code> の値がひとつインクリメントされます。
      </p>

      <p class="para">
       mysqlnd が ほぼすべての接続で デフォルトの <code class="literal">mysqlnd.net_cmd_buffer_size</code> (<var class="filename">php.ini</var> で設定) バイトを超えてバッファを拡張しなければならない場合、メモリの再割り当てを防ぐために、デフォルトの値を増やすことを検討すべきです。
      </p>

      <p class="para">
       デフォルトのバッファサイズは4096バイトです。これは設定可能な最小値です。このデフォルト値は <var class="filename">php.ini</var> の <code class="literal">mysqlnd.net_cmd_buffer_size</code> を設定するか、<code class="literal">mysqli_options(MYSQLI_OPT_NET_CMD_BUFFER_SIZE, int size)</code> 関数を使うことで変更することができます。
      </p>

      </td>
    </tr>

    <tr>
     <td><code class="literal">connection_reused</code></td>
     <td class="empty">&nbsp;</td>
     <td class="empty">&nbsp;</td>
     <td class="empty">&nbsp;</td>
    </tr>

   </tbody>
  
 </table>

</div>
</div></div></body></html>